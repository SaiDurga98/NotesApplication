// How SpringSecurity works internally???

Client -> Filter Chain -> Dispatcher Servlet -> Controller

Filter chain -> Filter 1 ...  Filter N
Filters are components that can intercept and modify incoming requests and outgoing responses in an application
Filter chain is a sequence of filters than an HTTP request and response pass through before reaching the targeted resource and after the resource has generated response.

The first filter in the chain receives the request and performs its processing
After processing, the filter calls chain.doFilter(request, response) to pass the request to next filter
The process continues until the request reaches the final resource
The response generated by the resource travels back through the chain, allowing each filter to perform any necessary post processing.

Why filters?//
- Cross cutting concerns
- Pre and Post processing
- Request and response manipulation
- Separation of concerns

Request -> Filter chain  ----> Dispatcher Servlet -> Controller
                |
SecurityContext- Authentication Filter(intercept login request and creates auth obj(initially not authenticated))
                    |
                    Authentication manager -> authenticate() -- Auth Provider (DaoAuthProvider) - matches() -- Password Encoder
                                                            |
                                                      UserDetailsService (loadByUserName) - findByUsername() -> Database

SecurityContext is available throughout the request and this contains the authenticated object

// Default behaviour in spring security
Default authentication is form based authentication( in built login and logout) in spring security
Default user and password are generated and password changes with every restart

// Understanding what happened in logs in this default behaviour??
UserDetailsServiceAutoConfiguration - takes place
GlobalAuthenticationManager configured with UserDetailsService bean with name InMemoryUserDetailsManager
FilterChains takes place like DefaultSecurityFilterChain, Cors Filter, CSRF filter, UserNamePasswordAuthenticationFilter, AuthorizationFilter

//Internal working
Req -> Default login Form -> Authorization filter -> UsernamePasswordAuthentication Filter -> Authenticate Manager (authenticate())
-> ProviderManager (loops through providers) -> Default Dao Auth Provider (authenticates the user) -> UserDetailsService.loadUserByUserName()
-> InMemoryUserDetailsManager (gets the UserDetails obj) -> Again to DaoAuthProvider -- matches the password using password encoder
-> again Authentication Filter (auth obj is set if successfully) -> set to Security Context....

//Key Filters
SecurityContextPersistenceFilter - Manages the security context for each request
WebAsyncManagerIntegrationFilter - Integrates the SecurityContext with Spring's WebAsyncManager for async web requests
HeaderWriterFilter - Add security-related HTTP headers to the response such as X-Content_type_Options, X-Frame Options and X-XSS--Protection
CorsFilter - Handlers CORS by allowing/denying requests from diff origins based on configured policies
CsrfFilter - Spring Security has inbuilt CSRF protection by generating and validating CSRF tokens for each request
UsernamePasswordAuthenticationFilter- Process auth requests for username and password credentials
DefaultLoginPageGeneratingFilter
DefaultLogoutPageGeneratingFilter
BasicAuthenticationFilter - Handler HTTP Basic Authentication by extracting credentials from AUTH Header and pass them to auth manager
RequestCacheAwareFilter - Ensures that original request URL is cached during auth, so that the user can be redirected to it after successful authentication

//JSessionId
It is a unique identifier used by java web applications to manage sessions
when a user interacts with a web app, server creates a session and this id is used to identify and maintain the session across multiple requests

//Basic Authentication
It is one of the simplest forms of authentication supported by Spring security
It involves sending the username and password with each HTTP request in the Authorization Header
The credentials are encoded using Base64 and sent over the network. Spring security then decodes and validates these credentials.

username:password -> Base64 Encoding -> Bas64 Encoded Value is passed into Auth header to backend in every request
-> Auth header -- Basic <base64 encoded value> -> Spring Security validates these credentials

// Difference between basic auth and form based authentication

Basic auth -> no form -> we get a popup to give credentials
Form based -> form is submitted and we see username, password and csrf token to be sent with the request

// Until now, session/state is being maintained
So to make it stateless we can do http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

// when making API requests we use postman
Add request URL -> basic auth -> username and password -> SEND or
Take the basic auth header which is :: Authorization Basic <base64 encoded value> and put in the headers with key as AUTHORIZATION and value as Basic <base64 encoded value>

// Authentication Providers - interface
These are components handle the actual verification of credentials provided by the user during the login process
It is an interface
Key responsibilities:
1. Authenticate the user
2. Once the authentication is successful, creates the authentication token
Importance:
1. Flexibility as it allows to provide configurations for different providers implementation like oauth2, LDAP or database
2. Separation of concerns like auth logic decoupled from the application
3. Extensibility
4. Security

// Different Auth Providers
1. DaoAuthenticationProvider : default : which implements AuthenticationProvider
2. InMemoryAuthenticationProvider : will not persist in db
3. LdapAuthenticationProvider : need to be configured externally
4. ActiveDirectoryLdapAuthenticationProvider
5. PreAuthenticatedAuthenticationProvider : Like for single sign on
6. OAuth2AuthenticationProvider : like google/github login

//Core classes & Interfaces of User management in Spring Security
                            <<UserDetails>> -- Interface is a core component that represents a user in the application such as username, password and authorities
                                     |
                            <<UserDetailsService>> -- Interfaces - responsible for retrieving user related data
                                     |
                            <<UserDetailsManager>>
                                     |
            jdbcUserDetailsManager     InMemoryUserDetailsManager   --> classes


UserDetails interface has getUsername(), getPassword(), getAuthorities(), isAccountNonExpired().....

User is a concrete implementation of UserDetails interface provided by Spring Security
It is often used to create a UserDetails obj with predefined username, password and authorities
        UserDetails user = User.withUsername("admin").withPassword("{noop}password").authorities("ROLE_ADMIN").build();

UserDetailsService - loadUserByUsername(String userName) - Fetch userInformation

UserDetailsManager extends UserDetailsService and provides additional methods for managing user accounts such as creating,deleting, updating users and changePassword

jdbcUserDetailsManager manages user details using a JDBC-based data source.
InMemoryUserDetailsManager manages user details entirely in the memory.(non persistent impl of UserDetailsManager)


// Custom User Model

why??
1. Extended UserInformation like more fields
2. Domain- Specific Requirements like for eg we have health domain we may have different fields
3. Custom Authentication and Authorization Logic
4. Integration with other systems
5. Enhanced Security Measures like Multi factor Authentication
                    UserDetails
                          | --------------------------------
                                                            |
                      User                                   Custom User Model  (complex user attributes)






































